import React from 'react';
import type { Meta, StoryObj } from '@storybook/react';
import { userEvent, within, expect, waitFor, fn } from '@storybook/test';
import { Box, Typography, IconButton, Avatar } from '@mui/material';
import HomeIcon from '@mui/icons-material/Home';
import SettingsIcon from '@mui/icons-material/Settings';
import HelpIcon from '@mui/icons-material/Help';
import PersonIcon from '@mui/icons-material/Person';
import NotificationsIcon from '@mui/icons-material/Notifications';
import DarkModeIcon from '@mui/icons-material/DarkMode';
import SaveIcon from '@mui/icons-material/Save';
import UndoIcon from '@mui/icons-material/Undo';
import RedoIcon from '@mui/icons-material/Redo';

import { Menubar } from './Menubar';
import { MenubarItem } from './Menubar.types';

const meta: Meta<typeof Menubar> = {
  title: 'Form/Menubar/Tests',
  component: Menubar,
  parameters: { 
    layout: 'fullscreen', 
    chromatic: { disableSnapshot: false },
    viewport: { defaultViewport: 'desktop' }
  },
  tags: ['autodocs', 'test'],
};
export default meta;
export type Story = StoryObj<typeof meta>;

// Test data
const basicMenuItems: MenubarItem[] = [
  {
    id: 'file',
    label: 'File',
    children: [
      { id: 'new', label: 'New File', shortcut: '⌘N', action: fn() },
      { id: 'open', label: 'Open...', shortcut: '⌘O', action: fn() },
      { id: 'save', label: 'Save', shortcut: '⌘S', action: fn(), icon: <SaveIcon fontSize="small" /> },
      { id: 'divider1', divider: true, label: '', action: fn() },
      { id: 'recent', label: 'Recent Files', children: [
        { id: 'file1', label: 'document.txt', action: fn() },
        { id: 'file2', label: 'presentation.pptx', action: fn() },
      ]},
    ],
  },
  {
    id: 'edit',
    label: 'Edit',
    children: [
      { id: 'undo', label: 'Undo', shortcut: '⌘Z', action: fn(), icon: <UndoIcon fontSize="small" /> },
      { id: 'redo', label: 'Redo', shortcut: '⌘⇧Z', action: fn(), icon: <RedoIcon fontSize="small" /> },
    ],
  },
  {
    id: 'view',
    label: 'View',
    disabled: true,
    children: [
      { id: 'zoom', label: 'Zoom', action: fn() },
    ],
  },
];

const Logo = () => (
  <Box sx={{ display: 'flex', alignItems: 'center', gap: 1 }}>
    <HomeIcon />
    <Typography variant="h6" sx={{ fontWeight: 'bold' }}>
      TestApp
    </Typography>
  </Box>
);

const EndContent = () => (
  <Box sx={{ display: 'flex', alignItems: 'center', gap: 1 }}>
    <IconButton color="inherit" size="small" data-testid="notifications-btn">
      <NotificationsIcon />
    </IconButton>
    <IconButton color="inherit" size="small" data-testid="darkmode-btn">
      <DarkModeIcon />
    </IconButton>
    <Avatar sx={{ width: 32, height: 32 }} data-testid="avatar">U</Avatar>
  </Box>
);

// 1. Basic Interaction Tests
export const BasicInteraction: Story = {
  args: {
    items: basicMenuItems,
    logo: <Logo />,
    endContent: <EndContent />,
  },
  play: async ({ canvasElement }) => {
    const canvas = within(canvasElement);
    
    // Test menu item clicking
    const fileButton = canvas.getByRole('button', { name: /file/i });
    await expect(fileButton).toBeInTheDocument();
    
    // Click file menu to open dropdown
    await userEvent.click(fileButton);
    
    // Wait for menu to open
    await waitFor(() => {
      const newMenuItem = canvas.getByText('New File');
      expect(newMenuItem).toBeVisible();
    });
    
    // Test nested menu item
    const newFileItem = canvas.getByText('New File');
    await userEvent.click(newFileItem);
    
    // Verify action was called
    await waitFor(() => {
      expect(basicMenuItems[0].children![0].action).toHaveBeenCalled();
    });
    
    // Test disabled menu
    const viewButton = canvas.getByRole('button', { name: /view/i });
    await expect(viewButton).toBeDisabled();
    
    // Test logo is present
    const logo = canvas.getByText('TestApp');
    await expect(logo).toBeInTheDocument();
    
    // Test end content
    const avatar = canvas.getByTestId('avatar');
    await expect(avatar).toBeInTheDocument();
  },
};

// 2. Form Interaction Tests
export const FormInteraction: Story = {
  args: {
    items: [
      {
        id: 'settings',
        label: 'Settings',
        icon: <SettingsIcon fontSize="small" />,
        children: [
          { id: 'profile', label: 'Profile Settings', action: fn() },
          { id: 'preferences', label: 'Preferences', action: fn() },
          { id: 'account', label: 'Account', action: fn() },
        ],
      },
      {
        id: 'help',
        label: 'Help',
        icon: <HelpIcon fontSize="small" />,
        action: fn(),
      },
    ],
    onClick: fn(),
    onFocus: fn(),
    onBlur: fn(),
  },
  play: async ({ canvasElement, args }) => {
    const canvas = within(canvasElement);
    
    // Test menu item with children
    const settingsButton = canvas.getByRole('button', { name: /settings/i });
    await userEvent.click(settingsButton);
    
    await waitFor(() => {
      const profileItem = canvas.getByText('Profile Settings');
      expect(profileItem).toBeVisible();
    });
    
    const profileItem = canvas.getByText('Profile Settings');
    await userEvent.click(profileItem);
    
    // Verify onClick callback is triggered
    await waitFor(() => {
      expect(args.onClick).toHaveBeenCalled();
    });
    
    // Test single action item
    const helpButton = canvas.getByRole('button', { name: /help/i });
    await userEvent.click(helpButton);
    
    await waitFor(() => {
      expect(args.onClick).toHaveBeenCalledTimes(2);
    });
    
    // Test focus events
    await userEvent.click(settingsButton);
    await waitFor(() => {
      expect(args.onFocus).toHaveBeenCalled();
    });
  },
};

// 3. Keyboard Navigation Tests  
export const KeyboardNavigation: Story = {
  args: {
    items: basicMenuItems,
    logo: <Logo />,
  },
  play: async ({ canvasElement }) => {
    const canvas = within(canvasElement);
    
    const fileButton = canvas.getByRole('button', { name: /file/i });
    const editButton = canvas.getByRole('button', { name: /edit/i });
    
    // Focus first menu item
    await userEvent.click(fileButton);
    await expect(fileButton).toHaveFocus();
    
    // Tab to next menu item
    await userEvent.keyboard('{Tab}');
    await expect(editButton).toHaveFocus();
    
    // Open menu with Enter
    await userEvent.keyboard('{Enter}');
    
    await waitFor(() => {
      const undoItem = canvas.getByText('Undo');
      expect(undoItem).toBeVisible();
    });
    
    // Navigate within menu with arrow keys
    await userEvent.keyboard('{ArrowDown}');
    const redoItem = canvas.getByText('Redo');
    await expect(redoItem).toBeVisible();
    
    // Close menu with Escape
    await userEvent.keyboard('{Escape}');
    
    await waitFor(() => {
      const undoItem = canvas.queryByText('Undo');
      expect(undoItem).not.toBeInTheDocument();
    });
  },
};

// 4. Screen Reader Tests
export const ScreenReader: Story = {
  args: {
    items: basicMenuItems,
    logo: <Logo />,
  },
  play: async ({ canvasElement }) => {
    const canvas = within(canvasElement);
    
    // Check ARIA attributes
    const fileButton = canvas.getByRole('button', { name: /file/i });
    await expect(fileButton).toHaveAttribute('type', 'button');
    
    // Check menu has proper ARIA structure
    await userEvent.click(fileButton);
    
    await waitFor(() => {
      const menu = canvas.getByRole('menu');
      expect(menu).toBeInTheDocument();
      expect(menu).toHaveAttribute('role', 'menu');
    });
    
    // Check menu items have proper roles
    const newFileItem = canvas.getByRole('menuitem', { name: /new file/i });
    await expect(newFileItem).toBeInTheDocument();
    
    // Check disabled items are properly marked
    const viewButton = canvas.getByRole('button', { name: /view/i });
    await expect(viewButton).toHaveAttribute('disabled');
    await expect(viewButton).toHaveAttribute('aria-disabled', 'true');
    
    // Check icons have proper labels
    const saveItem = canvas.getByText('Save');
    await expect(saveItem).toBeInTheDocument();
  },
};

// 5. Focus Management Tests
export const FocusManagement: Story = {
  args: {
    items: basicMenuItems,
    logo: <Logo />,
    endContent: <EndContent />,
  },
  play: async ({ canvasElement }) => {
    const canvas = within(canvasElement);
    
    // Test initial focus
    const fileButton = canvas.getByRole('button', { name: /file/i });
    await userEvent.click(fileButton);
    
    // Test menu opens and focuses correctly
    await waitFor(() => {
      const menu = canvas.getByRole('menu');
      expect(menu).toBeInTheDocument();
    });
    
    // Test focus trap within menu
    await userEvent.keyboard('{ArrowDown}');
    await userEvent.keyboard('{ArrowDown}');
    
    const saveItem = canvas.getByText('Save');
    await expect(saveItem).toBeVisible();
    
    // Test focus returns to trigger after menu closes
    await userEvent.keyboard('{Escape}');
    
    await waitFor(() => {
      expect(fileButton).toHaveFocus();
    });
    
    // Test end content focus
    const notificationBtn = canvas.getByTestId('notifications-btn');
    await userEvent.click(notificationBtn);
    await expect(notificationBtn).toHaveFocus();
  },
};

// 6. Responsive Design Tests
export const ResponsiveDesign: Story = {
  args: {
    items: basicMenuItems,
    logo: <Logo />,
    endContent: <EndContent />,
  },
  parameters: {
    viewport: { defaultViewport: 'mobile1' }
  },
  play: async ({ canvasElement }) => {
    const canvas = within(canvasElement);
    
    // Test component renders on mobile
    const toolbar = canvas.getByRole('toolbar');
    await expect(toolbar).toBeInTheDocument();
    
    // Test logo is still visible
    const logo = canvas.getByText('TestApp');
    await expect(logo).toBeInTheDocument();
    
    // Test menu items are still clickable
    const fileButton = canvas.getByRole('button', { name: /file/i });
    await userEvent.click(fileButton);
    
    await waitFor(() => {
      const newMenuItem = canvas.getByText('New File');
      expect(newMenuItem).toBeVisible();
    });
    
    // Test end content adapts
    const avatar = canvas.getByTestId('avatar');
    await expect(avatar).toBeInTheDocument();
  },
};

// 7. Theme Variations Tests
export const ThemeVariations: Story = {
  render: () => (
    <Box>
      {(['default', 'glass', 'gradient', 'elevated', 'minimal', 'bordered'] as const).map((variant) => (
        <Box key={variant} sx={{ mb: 2 }} data-testid={`variant-${variant}`}>
          <Typography variant="caption" sx={{ mb: 1, display: 'block' }}>
            Variant: {variant}
          </Typography>
          <Menubar
            items={basicMenuItems}
            variant={variant}
            color="primary"
            logo={<Logo />}
            glass={variant === 'glass'}
            gradient={variant === 'gradient'}
            glow={variant === 'glass'}
          />
        </Box>
      ))}
    </Box>
  ),
  play: async ({ canvasElement }) => {
    const canvas = within(canvasElement);
    
    // Test all variants render
    const variants = ['default', 'glass', 'gradient', 'elevated', 'minimal', 'bordered'];
    
    for (const variant of variants) {
      const variantElement = canvas.getByTestId(`variant-${variant}`);
      await expect(variantElement).toBeInTheDocument();
      
      const fileButton = within(variantElement).getByRole('button', { name: /file/i });
      await expect(fileButton).toBeInTheDocument();
    }
    
    // Test glass variant has specific styling
    const glassVariant = canvas.getByTestId('variant-glass');
    const glassFileButton = within(glassVariant).getByRole('button', { name: /file/i });
    await userEvent.click(glassFileButton);
    
    await waitFor(() => {
      const newMenuItem = within(glassVariant).getByText('New File');
      expect(newMenuItem).toBeVisible();
    });
  },
};

// 8. Visual States Tests
export const VisualStates: Story = {
  render: () => (
    <Box>
      <Typography variant="h6" gutterBottom>Loading State</Typography>
      <Menubar items={[]} loading logo={<Logo />} />
      
      <Typography variant="h6" gutterBottom sx={{ mt: 3 }}>Disabled State</Typography>
      <Menubar items={basicMenuItems} disabled logo={<Logo />} />
      
      <Typography variant="h6" gutterBottom sx={{ mt: 3 }}>Glass Effect</Typography>
      <Box sx={{ background: 'linear-gradient(135deg, #667eea 0%, #764ba2 100%)', p: 2 }}>
        <Menubar 
          items={basicMenuItems} 
          variant="glass" 
          glass 
          glow 
          transparent 
          blur
          logo={<Logo />} 
        />
      </Box>
      
      <Typography variant="h6" gutterBottom sx={{ mt: 3 }}>All Sizes</Typography>
      {(['xs', 'sm', 'md', 'lg', 'xl'] as const).map((size) => (
        <Box key={size} sx={{ mb: 1 }} data-testid={`size-${size}`}>
          <Typography variant="caption">{size}</Typography>
          <Menubar items={basicMenuItems} size={size} variant="bordered" />
        </Box>
      ))}
    </Box>
  ),
  play: async ({ canvasElement }) => {
    const canvas = within(canvasElement);
    
    // Test loading state
    const loadingIndicator = canvas.getByRole('progressbar');
    await expect(loadingIndicator).toBeInTheDocument();
    
    // Test disabled state  
    const disabledMenus = canvas.getAllByText('File');
    const disabledFileButton = disabledMenus[1]; // Second instance (disabled)
    await expect(disabledFileButton.closest('button')).toBeDisabled();
    
    // Test different sizes
    const sizes = ['xs', 'sm', 'md', 'lg', 'xl'];
    for (const size of sizes) {
      const sizeElement = canvas.getByTestId(`size-${size}`);
      await expect(sizeElement).toBeInTheDocument();
    }
    
    // Test glass variant renders
    const glassMenus = canvas.getAllByText('File');
    await expect(glassMenus[2]).toBeInTheDocument(); // Glass variant (third instance)
  },
};

// 9. Performance Tests
export const Performance: Story = {
  args: {
    items: Array.from({ length: 50 }, (_, i) => ({
      id: `item-${i}`,
      label: `Menu Item ${i + 1}`,
      children: Array.from({ length: 10 }, (_, j) => ({
        id: `subitem-${i}-${j}`,
        label: `Submenu ${i + 1}.${j + 1}`,
        action: fn(),
      })),
    })),
    logo: <Logo />,
  },
  play: async ({ canvasElement }) => {
    const canvas = within(canvasElement);
    
    const startTime = Date.now();
    
    // Test rendering performance with many items
    const firstMenuItem = canvas.getByRole('button', { name: 'Menu Item 1' });
    await expect(firstMenuItem).toBeInTheDocument();
    
    // Test interaction performance
    await userEvent.click(firstMenuItem);
    
    await waitFor(() => {
      const submenu = canvas.getByText('Submenu 1.1');
      expect(submenu).toBeVisible();
    });
    
    const endTime = Date.now();
    const renderTime = endTime - startTime;
    
    // Performance should be under 1000ms for this test
    expect(renderTime).toBeLessThan(1000);
    
    // Test menu closes quickly
    const closeStartTime = Date.now();
    await userEvent.keyboard('{Escape}');
    
    await waitFor(() => {
      const submenu = canvas.queryByText('Submenu 1.1');
      expect(submenu).not.toBeInTheDocument();
    });
    
    const closeTime = Date.now() - closeStartTime;
    expect(closeTime).toBeLessThan(1000);
  },
};

// 10. Edge Cases Tests
export const EdgeCases: Story = {
  render: () => (
    <Box>
      <Typography variant="h6" gutterBottom>Empty Menu</Typography>
      <Menubar items={[]} logo={<Logo />} />
      
      <Typography variant="h6" gutterBottom sx={{ mt: 3 }}>Very Long Labels</Typography>
      <Menubar 
        items={[
          {
            id: 'long',
            label: 'This is a very long menu item label that should handle text overflow gracefully',
            children: [
              { 
                id: 'long-child', 
                label: 'This is an extremely long submenu item that tests text wrapping and overflow behavior in dropdown menus',
                action: fn()
              },
            ],
          },
        ]}
        logo={<Logo />}
      />
      
      <Typography variant="h6" gutterBottom sx={{ mt: 3 }}>Mixed Item Types</Typography>
      <Menubar 
        items={[
          { id: 'normal', label: 'Normal Item', action: fn() },
          { id: 'sep1', divider: true, label: '', action: fn() },
          { id: 'with-icon', label: 'With Icon', icon: <PersonIcon />, action: fn() },
          { id: 'disabled', label: 'Disabled Item', disabled: true, action: fn() },
          { id: 'sep2', divider: true, label: '', action: fn() },
          { id: 'nested', label: 'Nested', children: [
            { id: 'deep', label: 'Deep Item', children: [
              { id: 'deeper', label: 'Deeper Item', action: fn() },
            ]},
          ]},
        ]}
        logo={<Logo />}
      />
    </Box>
  ),
  play: async ({ canvasElement }) => {
    const canvas = within(canvasElement);
    
    // Test empty menu renders without error
    const emptyMenubar = canvas.getAllByRole('toolbar')[0];
    await expect(emptyMenubar).toBeInTheDocument();
    
    // Test long label handling
    const longLabelButton = canvas.getByRole('button', { name: /this is a very long menu item/i });
    await expect(longLabelButton).toBeInTheDocument();
    
    await userEvent.click(longLabelButton);
    await waitFor(() => {
      const longSubmenu = canvas.getByText(/this is an extremely long submenu/i);
      expect(longSubmenu).toBeVisible();
    });
    
    // Test mixed item types
    const normalItem = canvas.getByRole('button', { name: 'Normal Item' });
    const withIconItem = canvas.getByRole('button', { name: 'With Icon' });
    const disabledItem = canvas.getByRole('button', { name: 'Disabled Item' });
    
    await expect(normalItem).toBeInTheDocument();
    await expect(withIconItem).toBeInTheDocument();
    await expect(disabledItem).toBeDisabled();
    
    // Test deeply nested menu
    const nestedButton = canvas.getByRole('button', { name: 'Nested' });
    await userEvent.click(nestedButton);
    
    await waitFor(() => {
      const deepItem = canvas.getByText('Deep Item');
      expect(deepItem).toBeVisible();
    });
  },
};

// 11. Integration Tests
export const Integration: Story = {
  render: () => (
    <Box>
      <Menubar
        items={[
          {
            id: 'actions',
            label: 'Actions',
            children: [
              { id: 'create', label: 'Create New', action: fn() },
              { id: 'import', label: 'Import Data', action: fn() },
              { id: 'export', label: 'Export Data', action: fn() },
            ],
          },
          {
            id: 'tools',
            label: 'Tools',
            children: [
              { id: 'calculator', label: 'Calculator', action: fn() },
              { id: 'converter', label: 'Converter', action: fn() },
            ],
          },
        ]}
        variant="elevated"
        color="primary"
        logo={<Logo />}
        endContent={<EndContent />}
        sticky
        onFocus={fn()}
        onBlur={fn()}
        onClick={fn()}
      />
      
      <Box sx={{ height: '150vh', p: 3 }}>
        <Typography variant="h4" gutterBottom>
          Integration Test Content
        </Typography>
        <Typography paragraph>
          This content tests the menubar integration with page scrolling and sticky behavior.
          The menubar should remain visible at the top when scrolling.
        </Typography>
        {Array.from({ length: 20 }, (_, i) => (
          <Typography key={i} paragraph>
            Lorem ipsum dolor sit amet, consectetur adipiscing elit. 
            Sed do eiusmod tempor incididunt ut labore et dolore magna aliqua.
          </Typography>
        ))}
      </Box>
    </Box>
  ),
  play: async ({ canvasElement }) => {
    const canvas = within(canvasElement);
    
    // Test integrated menubar renders correctly
    const toolbar = canvas.getByRole('toolbar');
    await expect(toolbar).toBeInTheDocument();
    
    // Test logo integration
    const logo = canvas.getByText('TestApp');
    await expect(logo).toBeInTheDocument();
    
    // Test end content integration
    const avatar = canvas.getByTestId('avatar');
    await expect(avatar).toBeInTheDocument();
    
    // Test menu integration
    const actionsButton = canvas.getByRole('button', { name: /actions/i });
    await userEvent.click(actionsButton);
    
    await waitFor(() => {
      const createItem = canvas.getByText('Create New');
      expect(createItem).toBeVisible();
    });
    
    const createItem = canvas.getByText('Create New');
    await userEvent.click(createItem);
    
    // Test sticky behavior by checking element positioning
    const menubarElement = toolbar.closest('[role="toolbar"]');
    await expect(menubarElement).toBeInTheDocument();
    
    // Test multiple menu interactions
    const toolsButton = canvas.getByRole('button', { name: /tools/i });
    await userEvent.click(toolsButton);
    
    await waitFor(() => {
      const calculatorItem = canvas.getByText('Calculator');
      expect(calculatorItem).toBeVisible();
    });
  },
};